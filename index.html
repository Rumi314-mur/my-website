<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Video Cuteee</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

        /* --- NEW: Lush Forest Color Theme --- */
        :root {
            --primary-color: #2ecc71; /* Vibrant Mint Green */
            --secondary-color: #f1c40f; /* Warm Gold */
            --bg-color: #1a3a3a; /* Deep Forest Teal */
            --text-color: #ecf0f1;
            --controls-bg: rgba(20, 30, 30, 0.85);
            --error-color: #e74c3c;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #root {
            width: 100%;
            max-width: 950px;
        }
        
        /* --- FILE UPLOADER & ERROR MESSAGE --- */
        .initial-screen {
            text-align: center;
            padding: 40px;
            border: 3px dashed var(--primary-color);
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(26, 58, 58, 0.5), rgba(46, 204, 113, 0.1));
            backdrop-filter: blur(5px);
        }
        .initial-screen h1 {
            margin-top: 0;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5em;
        }
        .custom-file-input {
            background: linear-gradient(90deg, var(--primary-color), #27ae60);
            color: #162b2b;
            padding: 12px 30px;
            border-radius: 30px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            display: inline-block;
            transition: all 0.3s ease;
            box-shadow: 0px 4px 15px rgba(46, 204, 113, 0.2);
        }
        .custom-file-input:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0px 8px 25px rgba(46, 204, 113, 0.4);
        }
        #videoFileInput { display: none; }
        
        .error-message {
            background-color: var(--error-color);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .error-message h3 { margin-top: 0; }
        
        /* --- PLAYER WRAPPER --- */
        .player-wrapper {
            position: relative; width: 100%;
            overflow: hidden; border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            background-color: #000;
        }
        video { width: 100%; display: block; }
        
        /* --- OVERLAYS & CONTROLS --- */
        .overlay-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .center-play-pause-animation {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(1.5);
            font-size: 60px; background-color: rgba(0,0,0,0.6);
            color: white; border-radius: 50%; padding: 20px;
            opacity: 0; transition: all 0.4s ease;
        }
        .center-play-pause-animation.show {
            transform: translate(-50%, -50%) scale(1); opacity: 1;
        }
        
        .controls-container {
            position: absolute; bottom: 0; left: 0; right: 0;
            padding: 5px; box-sizing: border-box;
            background: linear-gradient(to top, rgba(10,20,20,0.9), transparent);
            opacity: 1; transition: opacity 0.3s ease-out;
        }
        .player-wrapper.hide-controls .controls-container {
            opacity: 0; pointer-events: none;
        }
        
        /* Timeline */
        .timeline-container { padding: 5px 10px; cursor: pointer; }
        .timeline {
            height: 6px; background-color: rgba(255, 255, 255, 0.2);
            border-radius: 6px; transition: height 0.2s;
        }
        .timeline-container:hover .timeline { height: 12px; }
        .timeline-progress {
            height: 100%; width: 0%; border-radius: 6px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            position: relative;
        }
        .timeline-progress::after {
            content: ''; position: absolute; right: 0; top: 50%;
            transform: translate(50%, -50%) scale(0); width: 20px; height: 20px;
            background-color: var(--text-color); border-radius: 50%;
            transition: transform 0.2s;
        }
        .timeline-container:hover .timeline-progress::after {
            transform: translate(50%, -50%) scale(1);
        }
        
        /* Main Controls */
        .main-controls {
            display: flex; justify-content: space-between; align-items: center;
            padding: 5px 10px;
        }
        .left-controls, .right-controls { display: flex; align-items: center; gap: 15px; }
        .main-controls button {
            background: none; border: none; color: var(--text-color);
            font-size: 18px; cursor: pointer; padding: 5px;
            transition: color 0.2s, transform 0.2s;
        }
        .main-controls button:hover {
            color: var(--primary-color); transform: scale(1.1);
        }
        #volumeSlider {
            cursor: pointer; width: 80px; accent-color: var(--primary-color);
        }
        
        /* Settings Panel */
        .settings-panel {
            position: absolute; bottom: 65px; right: 15px;
            background: var(--controls-bg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 10px; padding: 15px; width: 200px;
            opacity: 0; transform: translateY(10px);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .settings-panel.show { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .setting { margin-bottom: 10px; }
        .setting label { font-weight: 600; margin-bottom: 5px; display: block; color: var(--primary-color); }
        .setting select {
            width: 100%; background-color: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--primary-color); border-radius: 5px; padding: 5px;
        }
        .setting select:focus {
            outline: none; box-shadow: 0 0 0 2px var(--secondary-color);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Helper Functions ---
        const formatTime = (timeInSeconds) => {
            if (isNaN(timeInSeconds)) return "00:00";
            const date = new Date(timeInSeconds * 1000);
            const hh = date.getUTCHours();
            const mm = date.getUTCMinutes().toString().padStart(2, '0');
            const ss = date.getUTCSeconds().toString().padStart(2, '0');
            return hh ? `${hh}:${mm}:${ss}` : `${mm}:${ss}`;
        };

        // --- NEW: More compatible fullscreen function ---
        const toggleFullscreen = (element) => {
            if (!document.fullscreenElement) {
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.mozRequestFullScreen) { // Firefox
                    element.mozRequestFullScreen();
                } else if (element.webkitRequestFullscreen) { // Chrome, Safari, Opera
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) { // IE/Edge
                    element.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        // --- VideoPlayer Component ---
        const VideoPlayer = ({ videoFile, onPlaybackError }) => {
            const videoRef = useRef(null);
            const playerWrapperRef = useRef(null);
            const timelineRef = useRef(null);
            const controlsTimeoutRef = useRef(null);
            
            const [isPlaying, setIsPlaying] = useState(false);
            const [volume, setVolume] = useState(1);
            const [isMuted, setIsMuted] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [playbackRate, setPlaybackRate] = useState(1);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [showControls, setShowControls] = useState(true);
            const [audioTracks, setAudioTracks] = useState([]);
            const [selectedAudioTrack, setSelectedAudioTrack] = useState(0);
            const [showCenterIcon, setShowCenterIcon] = useState('');

            useEffect(() => {
                const video = videoRef.current;
                if (!video) return;

                video.src = URL.createObjectURL(videoFile);
                video.load();

                const handleLoadedMetadata = () => setDuration(video.duration);
                const handleCanPlay = () => {
                    setAudioTracks(Array.from(video.audioTracks));
                    video.play();
                }
                const handleTimeUpdate = () => setCurrentTime(video.currentTime);
                const handlePlay = () => setIsPlaying(true);
                const handlePause = () => setIsPlaying(false);
                const handleVolumeChange = () => {
                    setIsMuted(video.muted);
                    setVolume(video.volume);
                };
                const handleEnded = () => setIsPlaying(false);
                
                // --- NEW: Error Handling ---
                const handleError = () => {
                   onPlaybackError();
                };

                video.addEventListener('loadedmetadata', handleLoadedMetadata);
                video.addEventListener('canplay', handleCanPlay);
                video.addEventListener('timeupdate', handleTimeUpdate);
                video.addEventListener('play', handlePlay);
                video.addEventListener('pause', handlePause);
                video.addEventListener('volumechange', handleVolumeChange);
                video.addEventListener('ended', handleEnded);
                video.addEventListener('error', handleError);

                return () => {
                    video.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    video.removeEventListener('canplay', handleCanPlay);
                    video.removeEventListener('timeupdate', handleTimeUpdate);
                    video.removeEventListener('play', handlePlay);
                    video.removeEventListener('pause', handlePause);
                    video.removeEventListener('volumechange', handleVolumeChange);
                    video.removeEventListener('ended', handleEnded);
                    video.removeEventListener('error', handleError);
                    URL.revokeObjectURL(video.src);
                };
            }, [videoFile, onPlaybackError]);

            // Handlers and other effects (mostly unchanged)...
            useEffect(() => {
                if(showCenterIcon) {
                    const timeout = setTimeout(() => setShowCenterIcon(''), 500);
                    return () => clearTimeout(timeout);
                }
            }, [showCenterIcon]);

            const togglePlay = useCallback(() => {
                const video = videoRef.current;
                if (video.paused) {
                    video.play().catch(onPlaybackError);
                    setShowCenterIcon('play');
                } else {
                    video.pause();
                    setShowCenterIcon('pause');
                }
            }, [onPlaybackError]);
            
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (document.activeElement.tagName.toLowerCase().match(/input|select/)) return;
                    switch (e.key.toLowerCase()) {
                        case ' ': e.preventDefault(); togglePlay(); break;
                        case 'm': videoRef.current.muted = !videoRef.current.muted; break;
                        case 'f': toggleFullscreen(playerWrapperRef.current); break;
                        case 'arrowright': videoRef.current.currentTime += 5; break;
                        case 'arrowleft': videoRef.current.currentTime -= 5; break;
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [togglePlay]);
            
            const handleMouseMove = () => {
                setShowControls(true);
                clearTimeout(controlsTimeoutRef.current);
                if (!videoRef.current.paused) {
                  controlsTimeoutRef.current = setTimeout(() => setShowControls(false), 3000);
                }
            };
            
            const handleAudioTrackChange = (e) => {
                const trackIndex = parseInt(e.target.value, 10);
                videoRef.current.audioTracks.forEach((track, index) => {
                    track.enabled = (index === trackIndex);
                });
                setSelectedAudioTrack(trackIndex);
            };
            
            // Render logic...
            return (
                <div 
                    ref={playerWrapperRef} 
                    className={`player-wrapper ${!showControls || isSettingsOpen ? '' : 'hide-controls'}`}
                    onMouseMove={handleMouseMove}
                    onMouseLeave={() => { if(!videoRef.current.paused) setShowControls(false) }}
                >
                    <video ref={videoRef} onClick={togglePlay}></video>
                    {/* Other JSX for overlays and controls... */}
                    <div className="overlay-container">
                        <div className={`center-play-pause-animation ${showCenterIcon ? 'show' : ''}`}>
                             <i className={`fas ${showCenterIcon === 'play' ? 'fa-play' : 'fa-pause'}`}></i>
                        </div>
                    </div>
                    <div className="controls-container">
                        {/* Timeline */}
                        <div className="timeline-container" ref={timelineRef} onClick={(e) => {
                            const rect = e.currentTarget.getBoundingClientRect();
                            videoRef.current.currentTime = ((e.clientX - rect.left) / rect.width) * duration;
                        }}>
                            <div className="timeline">
                                <div className="timeline-progress" style={{ width: `${(currentTime / duration) * 100 || 0}%` }}></div>
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="main-controls">
                            <div className="left-controls">
                                <button onClick={togglePlay}><i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'}`}></i></button>
                                <div className="volume-container">
                                    <button onClick={() => videoRef.current.muted = !videoRef.current.muted}><i className={`fas ${isMuted || volume === 0 ? 'fa-volume-xmark' : volume < 0.5 ? 'fa-volume-low' : 'fa-volume-high'}`}></i></button>
                                    <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value={volume} onChange={(e) => videoRef.current.volume = e.target.value} />
                                </div>
                                <span>{formatTime(currentTime)} / {formatTime(duration)}</span>
                            </div>
                            <div className="right-controls">
                                <button onClick={() => setIsSettingsOpen(!isSettingsOpen)}><i className="fas fa-cog"></i></button>
                                <button onClick={() => toggleFullscreen(playerWrapperRef.current)}><i className="fas fa-expand"></i></button>
                            </div>
                        </div>
                    </div>
                    {/* Settings Panel */}
                    <div className={`settings-panel ${isSettingsOpen ? 'show' : ''}`}>
                         <div className="setting">
                            <label htmlFor="speed">Playback Speed</label>
                            <select id="speed" value={playbackRate} onChange={(e) => {
                                videoRef.current.playbackRate = parseFloat(e.target.value);
                                setPlaybackRate(parseFloat(e.target.value));
                            }}>
                                <option value="0.5">0.5x</option><option value="0.75">0.75x</option><option value="1">1x</option><option value="1.5">1.5x</option><option value="2">2x</option>
                            </select>
                        </div>
                        {audioTracks.length > 1 ? (
                            <div className="setting">
                                <label htmlFor="audio-track">Audio Track</label>
                                <select id="audio-track" value={selectedAudioTrack} onChange={handleAudioTrackChange}>
                                    {audioTracks.map((track, index) => (
                                        <option key={index} value={index}>{track.label || `Track ${index + 1}`} ({track.language || 'unknown'})</option>
                                    ))}
                                </select>
                            </div>
                        ) : <p style={{fontSize: '0.8em', textAlign: 'center', opacity: 0.7}}>Single audio track</p>}
                    </div>
                </div>
            );
        };
        
        // --- Main App Component ---
        const App = () => {
            const [videoFile, setVideoFile] = useState(null);
            // --- NEW: State for handling playback errors ---
            const [error, setError] = useState('');

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setError(''); // Reset error on new file selection
                    setVideoFile(file);
                }
            };
            
            const handlePlaybackError = useCallback(() => {
                setError('Playback Error: This video format or codec may not be supported by your browser. Please try a different file, like an MP4 with H.264 video.');
                setVideoFile(null); // Return to the upload screen
            }, []);

            if (!videoFile) {
                return (
                    <div className="initial-screen">
                        <h1>Universal Player</h1>
                        <p>A beautiful player designed to work everywhere. Pick a video to start.</p>
                        <label htmlFor="videoFileInput" className="custom-file-input">
                            <i className="fas fa-video"></i> Choose Video File
                        </label>
                        <input type="file" id="videoFileInput" onChange={handleFileChange} accept="video/*,.mkv" />
                        {error && (
                            <div className="error-message">
                                <h3>Oops! Something went wrong.</h3>
                                <p>{error}</p>
                            </div>
                        )}
                    </div>
                );
            }

            return <VideoPlayer videoFile={videoFile} onPlaybackError={handlePlaybackError} />;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
